/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package net.technikumwien.bic4b18_01.server.common;

import at.falb.games.alcatraz.api.Player;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.technikumwien.bic4b18_01.common.assist.TODO;
import net.technikumwien.bic4b18_01.common.assist.TraceHelper;
import net.technikumwien.bic4b18_01.common.exception.GameException;
import net.technikumwien.bic4b18_01.common.rmi.GameInfo;
import net.technikumwien.bic4b18_01.common.rmi.MoveInfo;
import net.technikumwien.bic4b18_01.server.applicationMW.Middleware;
import net.technikumwien.bic4b18_01.server.applicationMW.ToClient;
import net.technikumwien.bic4b18_01.server.common.Game;
import spread.SpreadException;
import spread.SpreadMessage;

/**
 *
 * @author Florian
 */
public class GameList {

    private static final Logger logger = Logger.getLogger(TraceHelper.getClassName());
    private static final Map<Integer, Game> openGames = new HashMap(); // gameID -> gameInstance
    private static final Map<Integer, Game> activeGames = new HashMap(); // gameID -> gameInstance
    private static final Map<Integer, Game> closingGames = new HashMap(); // gameID -> gameInstance
    private static final Map<String, Integer> userID_gameID = new HashMap(); // connection [IP:PORT] -> gameID

    private static final ReadWriteLock lock = new ReentrantReadWriteLock();

    public static SpreadMessage generateUpdate(SpreadMessage sm) {
        Middleware.serverStateLock.writeLock().lock();
        try {
            sm.digest(new HashMap(openGames));
            sm.digest(new HashMap(activeGames));
            sm.digest(new HashMap(closingGames));
            sm.digest(new HashMap(userID_gameID));
        } catch (SpreadException ex) {
            logger.log(Level.SEVERE, null, ex);
        } finally {
            Middleware.serverStateLock.writeLock().unlock();
        }
        return sm;
    }

    public static void update(Map<Integer, Game> openGamesUpdate, Map<Integer, Game> activeGamesUpdate, Map<Integer, Game> closingGamesUpdate, Map<String, Integer> userID_gameIDUpdate) {
        logger.log(Level.INFO, "{0} -> update", new Object[]{Thread.currentThread().getName()});
        Middleware.serverStateLock.writeLock().lock();
        try {
            openGames.clear();
            openGames.putAll(openGamesUpdate);
            activeGames.clear();
            activeGames.putAll(activeGamesUpdate);
            closingGames.clear();
            closingGames.putAll(closingGamesUpdate);
            userID_gameID.clear();
            userID_gameID.putAll(userID_gameIDUpdate);
        } finally {
            Middleware.serverStateLock.writeLock().unlock();
        }
    }

    public static Set<GameInfo> getOpenGames() {
        Middleware.serverStateLock.readLock().lock();
        lock.readLock().lock();
        Set<GameInfo> games = new HashSet();
        try {
            openGames.entrySet().forEach((e) -> {
                games.add(e.getValue().getGameInfo()); // copy
            });
        } finally {
            lock.readLock().unlock();
            Middleware.serverStateLock.readLock().unlock();
        }
        return games;
    }

    public static GameInfo getGameInfo(int gameID) throws GameException {
        Middleware.serverStateLock.readLock().lock();
        lock.readLock().lock();
        Game game;
        try {
            game = openGames.get(gameID);
            if (game != null) {
                return game.getGameInfo();
            }
            game = activeGames.get(gameID);
            if (game != null) {
                return game.getGameInfo();
            }
            game = closingGames.get(gameID);
            if (game != null) {
                return game.getGameInfo();
            }
        } finally {
            lock.readLock().unlock();
            Middleware.serverStateLock.readLock().unlock();
        }
        throw new GameException("Game could not be found.");
    }

    public static GameInfo newGame(final String connection, final String playerName, final int gameSize) throws GameException {
        Middleware.serverStateLock.readLock().lock();
        lock.writeLock().lock();
        final Game game = new Game(gameSize);
        try {
            game.addPlayer(playerName, connection);
            openGames.put(game.getGameID(), game);
            userID_gameID.put(connection, game.getGameID());
        } finally {
            lock.writeLock().unlock();
            Middleware.serverStateLock.readLock().unlock();
        }
        return game.getGameInfo();//copy
    }

    public static Game addPlayerToGame(final String connection, final String playerName, final int gameID) throws GameException {
        Middleware.serverStateLock.readLock().lock();
        lock.writeLock().lock();
        final Game game;
        try {
            game = openGames.get(gameID);
            if (game == null) {
                if (activeGames.containsKey(gameID) || closingGames.containsKey(gameID)) {
                    throw new GameException("Can not join game, already started.");
                }
                throw new GameException("Game could not be found.");
            }
            game.addPlayer(playerName, connection);
            // player could be added
            //ToSpreadGroup.sendAsynchron_playerChange(connection, game.getGameInfo());
            userID_gameID.put(connection, game.getGameID());
            if (game.isFull()) {
                openGames.remove(gameID);
                activeGames.put(gameID, game);
                //ToClient.startGame(new Game(game));// copy
            } else {
                openGames.put(gameID, game);
            }
        } finally {
            lock.writeLock().unlock();
            Middleware.serverStateLock.readLock().unlock();
        }
        return new Game(game);//copy
    }

    /**
     * remove the player on given connection from his game,
     * returning the left game,
     * returning null if no such game exists or game is already closing.
     *
     * @param connection
     * @return GameInfo of left game OR null if client not in any game or it is
     * closing
     * @throws GameException
     */
    public static Game removePlayerFromHisGame(final String connection) throws GameException {
        Middleware.serverStateLock.readLock().lock();
        lock.writeLock().lock();
        try {
            Integer gameID = userID_gameID.get(connection);
            if (gameID == null) {
                return null; //Player not in any game
            }
            return removePlayerFromGame(connection, gameID);
        } finally {
            lock.writeLock().unlock();
            Middleware.serverStateLock.readLock().unlock();
        }
    }

    public static Game removePlayerFromGame(final String connection, int gameID) throws GameException {
        Middleware.serverStateLock.readLock().lock();
        lock.writeLock().lock();
        final Game game;
        try {
            if (openGames.containsKey(gameID)) {
                game = openGames.get(gameID);
                Player player = game.removePlayer(connection);
                if (player == null) {
                    return null;
                }
                userID_gameID.remove(connection);
                if (game.isEmpty()) {
                    openGames.remove(gameID);
                } else {
                    openGames.put(gameID, game);
                }
                return new Game(game);//copy;
            }
            if (activeGames.containsKey(gameID)) {
                game = activeGames.get(gameID);
                if (game.getConnections().contains(connection)) {
                    throw new GameException("Can not leave game, already started.");
                }
                return null;
            }
            if (closingGames.containsKey(gameID)) {
                //left a closing game -> possible
                /*
                game = closingGames.get(gameID);
                game.removePlayer(connection);
                if (game.isEmpty()) {
                    closingGames.remove(gameID);
                } else {
                    closingGames.put(gameID, game);
                }
                */
                closingGames.remove(gameID);
                userID_gameID.remove(connection);
                return null;
            }
            userID_gameID.remove(connection);
            return null;
        } finally {
            lock.writeLock().unlock();
            Middleware.serverStateLock.readLock().unlock();
        }
    }

    //Server informiert die restlichen Spieler/Clients Ã¼ber den Sieger (stellvertretend)
    public static Game closeMyGame(final String connection) throws GameException {
        Middleware.serverStateLock.readLock().lock();
        lock.writeLock().lock();
        final Game game;
        try {
            Integer gameID = userID_gameID.get(connection);
            if (gameID == null) {
                return null; // client not part of any game.
            }
            game = activeGames.get(gameID);
            if (game == null) {
                return null; // game already closed
            }
            if (!game.getConnections().contains(connection)) {
                throw new GameException("Client not part of given game.");
            }
            activeGames.remove(gameID);
            closingGames.put(gameID, game);
            return new Game(game);//copy
        } finally {
            lock.writeLock().unlock();
            Middleware.serverStateLock.readLock().unlock();
        }
    }

    public static void unregisterClient(final String connection) {
        Middleware.serverStateLock.readLock().lock();
        lock.writeLock().lock();
        try {
            userID_gameID.remove(connection);
        } finally {
            lock.writeLock().unlock();
            Middleware.serverStateLock.readLock().unlock();
        }
    }
}
