/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package net.technikumwien.bic4b18_01.client.connectionMW;

import java.net.MalformedURLException;
import java.rmi.Naming;
import java.rmi.NoSuchObjectException;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayDeque;
import java.util.Random;
import java.util.Set;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import net.technikumwien.bic4b18_01.client.rmi.Server2Client;
import net.technikumwien.bic4b18_01.common.assist.TraceHelper;
import net.technikumwien.bic4b18_01.common.exception.ConnectionException;
import net.technikumwien.bic4b18_01.common.exception.GameException;
import net.technikumwien.bic4b18_01.common.rmi.GameInfo;
import net.technikumwien.bic4b18_01.common.rmi.MoveInfo;
import net.technikumwien.bic4b18_01.common.rmi.RMI_Client2Server;
import net.technikumwien.bic4b18_01.common.rmi.RMI_Server2Client;
import net.technikumwien.bic4b18_01.common.rmi.RMI_Services;
import net.technikumwien.bic4b18_01.common.rmi.Server;

/**
 * package access only
 *
 * @author Florian
 */
class ToServer implements IClient2ServerMW {

    /**
     *
     */
    private static Data DATA;
    private static final Logger logger = Logger.getLogger(TraceHelper.getClassName());

    private ToServer() {
    }

    public static ToServer getInstance() {
        return InstanceHolder.INSTANCE;
    }

    private static class InstanceHolder {

        private static final ToServer INSTANCE = new ToServer();
    }

    static String construct() {
        System.setProperty("sun.rmi.transport.tcp.responseTimeout", 60000 + "");

        logger.log(Level.INFO, "creating client-constructtion UUID");
        UUID clientCUID = UUID.randomUUID(); //

        DATA = Data.getInstance();
        Registry localRegistry;
        String connection;
        int startPort = (new Random()).nextInt(Server.maxPort() - Server.minPort() + 1) + Server.minPort();
        int port=startPort;
        int requestNr = 0;
        //get a stub
        while (true) {
            if(port>Server.maxPort()){
                port=Server.minPort();
            }
            try {
                //register local registry
                localRegistry = LocateRegistry.createRegistry(port);
                logger.log(Level.INFO, "localRegistry created on {0}", "" + port);
            } catch (RemoteException ex1) {
                //could not create registry on port
                logger.log(Level.SEVERE, "could not create local registry on port: " + port, ex1);
                port++;
                if(port==startPort) noFreePort();
                continue;
            }
            try {
                connection = registerClient(clientCUID,port);
                logger.log(Level.INFO, "global portID is {0}", "" + port);
            } catch (ConnectionException ex) {
                
                try {
                    UnicastRemoteObject.unexportObject(localRegistry, true);
                } catch (NoSuchObjectException ex1) {
                    logger.log(Level.INFO, "localRegistry already unexported", ex1);
                }
                port++;
                if(port==startPort) noFreePort();
                continue;
            }
            try {
                //bind RMI
                RMI_Server2Client server2clientSkeleton = new Server2Client();
                UnicastRemoteObject.exportObject(server2clientSkeleton, port);
                Naming.rebind("rmi://" + connection + "/" + RMI_Services.server2client.toString(), server2clientSkeleton);
                logger.log(Level.INFO, "{0} bound to {1}", new Object[]{RMI_Services.server2client, "" + connection});
            } catch (RemoteException | MalformedURLException ex1) {
                //shouldn't reach
                logger.log(Level.SEVERE, "local registry error [HOW?]", ex1);
                disconnect();
                port++;
                if(port==startPort) noFreePort();
                try {
                    UnicastRemoteObject.unexportObject(localRegistry, true);
                } catch (NoSuchObjectException ex) {
                    logger.log(Level.INFO, "localRegistry already unexported", ex);
                }
                //-> need to free port too. no idea how tho
                continue;
            }
            requestNr++;
            break;
        }

        //save everything in DATA
        DATA.setPort(port);
        DATA.setRequestNr(requestNr);

        return connection;
    }

    private static void noFreePort() {
        logger.log(Level.SEVERE, "no free port for your IP");
        try {
            Thread.sleep(60000);// timeout 1min
        } catch (InterruptedException ex2) {
            //wakeUP
        }
    }

    static String destruct() {
        System.clearProperty("sun.rmi.transport.tcp.responseTimeout");

        // server connection
        String connection = disconnect();
        try {
            Naming.unbind("rmi://" + connection + "/" + RMI_Services.server2client.toString());
        } catch (RemoteException | NotBoundException | MalformedURLException ex) {
            logger.log(Level.WARNING, "could not unbind rmi service " + RMI_Services.server2client.toString(), ex);
        }
        Data.destroyInstance();
        return connection;
    }

    //######################################################################
    //player driven functionalities
    @Override
    public Set<GameInfo> getGames()
            throws ConnectionException {
        if (DATA == null) {
            throw new ConnectionException("server hasn't acknowledged this client - please use construct() first");
        }
        Set<GameInfo> games = null;
        int port = DATA.getPort();
        int requestNr = DATA.getRequestNr();
        RMI_Client2Server stub = DATA.getStub();
        while (true) {
            try {
                games = stub.getGames(port);
                break;
            } catch (RemoteException ex1) {
                //server gone offline (no connection to current server)
                logger.log(Level.WARNING, "no connection to current server -> looking for different one", ex1);
                stub = generateStub();
            }
        }
        requestNr++;
        DATA.setRequestNr(requestNr);
        DATA.setStub(stub);
        return games;
    }
    
    @Override
    public GameInfo getGameInfo(int gameID)
            throws GameException, ConnectionException {
        if (DATA == null) {
            throw new ConnectionException("server hasn't acknowledged this client - please use construct() first");
        }
        GameInfo game = null;
        int port = DATA.getPort();
        int requestNr = DATA.getRequestNr();
        RMI_Client2Server stub = DATA.getStub();
        while (true) {
            try {
                game = stub.getGameInfo(port, gameID);
                break;
            } catch (RemoteException ex1) {
                //server gone offline (no connection to current server)
                logger.log(Level.WARNING, "no connection to current server -> looking for different one", ex1);
                stub = generateStub();
            }
        }
        requestNr++;
        DATA.setRequestNr(requestNr);
        DATA.setStub(stub);
        return game;
    }

    @Override
    public GameInfo hostGame(int players, String playerName)
            throws GameException, ConnectionException {//throws exception: to few/many players
        if (DATA == null) {
            throw new ConnectionException("server hasn't acknowledged this client - please use construct() first");
        }

        GameInfo gameInfo = null;
        int port = DATA.getPort();
        int requestNr = DATA.getRequestNr();
        RMI_Client2Server stub = DATA.getStub();
        while (true) {
            try {
                //Der tatsÃ¤chliche RMI-Aufruf findet hier statt
                gameInfo = stub.hostGame(port, requestNr, players, playerName);
                break;
            } catch (RemoteException ex1) {
                //server gone offline (no connection to current server)
                logger.log(Level.WARNING, "no connection to current server -> looking for different one", ex1);
                stub = generateStub();
            }
        }
        requestNr++;
        DATA.setRequestNr(requestNr);
        DATA.setStub(stub);
        return gameInfo;
    }

    @Override
    public GameInfo joinGame(int gameID, String playerName)
            throws GameException, ConnectionException {//throws exception: already full, no such game, player name already used
        if (DATA == null) {
            throw new ConnectionException("server hasn't acknowledged this client - please use construct() first");
        }

        GameInfo gameInfo = null;
        int port = DATA.getPort();
        int requestNr = DATA.getRequestNr();
        RMI_Client2Server stub = DATA.getStub();
        while (true) {
            try {
                gameInfo = stub.joinGame(port, requestNr, gameID, playerName);
                break;
            } catch (RemoteException ex1) {
                //server gone offline (no connection to current server)
                logger.log(Level.WARNING, "no connection to current server -> looking for different one", ex1);
                stub = generateStub();
            }
        }
        requestNr++;
        DATA.setRequestNr(requestNr);
        DATA.setStub(stub);
        return gameInfo;
    }

    @Override
    public void leaveGame()
            throws GameException, ConnectionException {//throws exception: already full, no such game
        if (DATA == null) {
            throw new ConnectionException("server hasn't acknowledged this client - please use construct() first");
        }

        int port = DATA.getPort();
        int requestNr = DATA.getRequestNr();
        RMI_Client2Server stub = DATA.getStub();
        while (true) {
            try {
                DATA.getStub().leaveGame(port, requestNr);
                break;
            } catch (RemoteException ex1) {
                //server gone offline (no connection to current server)
                logger.log(Level.WARNING, "no connection to current server -> looking for different one", ex1);
                stub = generateStub();
            }
        }
        requestNr++;
        DATA.setRequestNr(requestNr);
        DATA.setStub(stub);
    }

    @Override
    public void closeApp() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    //######################################################################
    // automatic functionalities
    public void endGame(ArrayDeque<MoveInfo> lastMoves)
            throws GameException, ConnectionException {

        if (DATA == null) {
            throw new ConnectionException("server hasn't acknowledged this client - please use construct() first");
        }
        int port = DATA.getPort();
        int requestNr = DATA.getRequestNr();
        RMI_Client2Server stub = DATA.getStub();
        while (true) {
            try {
                stub.endGame(port, requestNr, lastMoves);
            } catch (RemoteException ex) {
                //server gone offline (no connection to current server)
                logger.log(Level.WARNING, "no connection to current server -> looking for different one", ex);
                stub = generateStub();
            }
            break;
        }
        requestNr++;
        DATA.setRequestNr(requestNr);
        DATA.setStub(stub);
    }

    //######################################################################
    private static RMI_Client2Server generateStub() {

        logger.log(Level.INFO, "generating stub");
        RMI_Client2Server stub = null;
        while (true) {
            for (String serverIP : Server.adresses()) {
                logger.log(Level.INFO, "trying stub for {0}", serverIP);
                try {
                    stub = (RMI_Client2Server) Naming.lookup("rmi://" + serverIP + "/" + RMI_Services.client2server.toString()+"_"+serverIP);
                    logger.log(Level.INFO, "stub to {0} generated", serverIP);
                    break;
                } catch (NotBoundException | MalformedURLException | RemoteException ex) {
                    logger.log(Level.INFO, "can not generate stub to {0} at this time", serverIP);
                    logger.log(Level.FINEST, "detailed:", ex);
                }
            }
            if (stub == null) {
                //no server online (client offline)
                logger.log(Level.SEVERE, "no connection to any server -> retrying later");
                try {
                    Thread.sleep(60000);// timeout 1min
                } catch (InterruptedException ex3) {
                    //wakeUP
                }
                continue;
            }
            break;
        }
        return stub;
    }

    /**
     *
     * @param stub
     * @param port
     * @return
     * @throws RemoteException
     */
    private static String registerClient(UUID cUID, int port) throws ConnectionException {

        RMI_Client2Server stub = DATA.getStub();
        if (stub == null) {
            stub = generateStub();
        }
        while (true) {
            try {
                logger.log(Level.INFO, "trying to get port {0} in servercollective", "" + port);
                String connection = stub.registerClient(cUID, port); //throws exception: port taken
                logger.log(Level.INFO, "got connection on port: {0}", "" + port);
                return connection;
            } catch (RemoteException ex) {
                logger.log(Level.INFO, "stub is unreachable");
                stub = generateStub();
                DATA.setStub(stub);
            }
        }
    }

    private static String disconnect() {

        int port = DATA.getPort();
        int requestNr = DATA.getRequestNr();
        RMI_Client2Server stub = DATA.getStub();
        while (true) {
            try {
                String connection = stub.unregisterClient(port, requestNr);
                logger.log(Level.INFO, "disconnected from sever");
                return connection;
            } catch (RemoteException | ConnectionException | GameException ex) {
                logger.log(Level.SEVERE, null, ex);
                stub = generateStub();
            }
        }
    }

    //######################################################################
    /**
     * used for client 2 server connections outside a game
     */
    private static class Data { //singleton

        private RMI_Client2Server stub;
        private int port;
        private int requestNr;

        private Data() {
            this.stub = generateStub();
            this.port = Server.maxPort();
            this.requestNr = 0;
        }

        //##################################################################
        public static Data getInstance() {
            if (InstanceHolder.INSTANCE == null) {
                InstanceHolder.INSTANCE = new Data();
            }
            return InstanceHolder.INSTANCE;
        }

        public static void destroyInstance() {
            InstanceHolder.INSTANCE = null;
        }

        private static class InstanceHolder {

            private static Data INSTANCE = null;
        }

        //##################################################################
        public RMI_Client2Server getStub() {
            return this.stub;
        }

        public int getPort() {
            return this.port;
        }

        public int getRequestNr() {
            return this.requestNr;
        }

        public void setStub(RMI_Client2Server stub) {
            this.stub = stub;
        }

        public void setPort(int port) {
            this.port = port;
        }

        public void setRequestNr(int requestNr) {
            this.requestNr = requestNr;
        }
    }
}
